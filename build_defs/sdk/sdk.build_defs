def proto_build_defs(name:str, srcs:str|list, proto_languages:dict, visibility=["PUBLIC"]):
    """Exposes `.build_defs` containing `proto_language()` rules

    name (str): The name of this rule
    src (str|list): The .build_defs files containing the definition
    proto_languages (dict): A map of proto language types to functions that return the `proto_language()` below.
                            e.g. `{"grpc_language": ["go_grpc_language"], "proto_language": ["go_proto_language"]}`
                            where `go_grpc_language` is a function that has a `return proto_language(...)`
    """
    labels = []
    for type, langs in proto_languages.items():
        labels += [f"{type}:{lang}" for lang in langs]
    return filegroup(
       name = name,
       srcs = srcs,
       visibility = visibility,
       labels = labels,
   )

def proto_language(language:str, build_def:function, additional_provides:list|dict=[]):
    """Returns the definition of how to build a particular language for proto_library or grpc_library.

    This should be wrapped in a function so that the proto_languages() build definition below can 
    
    Args:
      language (str): Name of the language (as we would name it).
      build_def (function): The build definition lambda. Will be called with the same arguments proto_library
                            was called with, except with an additional `tag` parameter which is to be applied to the
                            final build rule. Should return
      additional_provides (list|dict): Any additional tags from the rule generated by func that should be provided by
                                       the final proto_library rule. The _{name}#{language} tag will already be provided.
                                       Can be a dictionary if the provide key on the `proto_library` should differ from
                                       the language rule. In which case, the key will be the key on the proto_library,
                                       and the value will be the tag to provide from build_def.
    """
    return {
        'language': language,
        'build_def': build_def,
        'additional_provides': additional_provides,
    }

def _get_languages_prebuild(label_prefix, includes):
    def pre_build(name):
        subincludes = ", ".join([f"\\\"{i}\\\"" for i in includes])
        language_defs = ", ".join(get_labels(name, label_prefix))
        build_def = [
            f"echo \"subinclude({subincludes})\" >> $OUT",
            f"echo \"def {name}():\" >> $OUT",
            f"echo \"    langs = [l() for l in [{language_defs}]]\" >> $OUT",
             "echo \"    return {l.language: l for l in langs}\" >> $OUT",
        ]
        set_command(name, " && ".join(build_def))

    return pre_build

def protoc_plugins(name:str, build_defs: list, label_prefix:str, visibility=["PUBLIC"]):
    """Used to define a set of language definitions, that can be subincluded by the 
    proto build rules.

    name (str): The name of the rule
    build_defs (list): Build rules outputting the .build_defs files that contain the 
                              proto_language() definitions.  
    label_prefix (str): The label prefix that must be applied to the build_defs above,
                        that identifies a function that returns the result of the above
                         `proro_language()` call. 
    """
    return build_rule(
        name = name,
        outs = [f"{name}.build_defs"],
        pre_build = _get_languages_prebuild(label_prefix, build_defs),
        deps = build_defs,
        visibility = visibility,
    )

def _collect_protoc_flags(prebuild):
    """Defines a pre-build function that updates a build command with transitive protoc flags."""
    def ret(name):
        labels = get_labels(name, 'protoc:')
        if labels:
            cmd = get_command(name)
            set_command(name, cmd.replace('$TOOLS_PROTOC ', '$TOOLS_PROTOC %s ' % ' '.join(labels)))
        if prebuild:
            prebuild(name)
    return ret

def protoc_rule(name:str, srcs:list, deps:list, language:str, tools:dict={}, protoc_flags:list, root_dir:str,
                pre_build:function=None, labels:list, test_only:bool, visibility:list):

    tools["protoc"] = [CONFIG.PROTO.PROTOC_TOOL]

    flags = [' '.join(protoc_flags)] + CONFIG.PROTO.PROTOC_FLAGS

    out_dir = "out_dir"
    language_out_dir = language

    cmd = f'$TOOLS_PROTOC -I. ' + ' '.join(flags)
    if root_dir:
        escaped_root_dir = root_dir.replace("/", "\/")
        cmd = f'cd {root_dir}; {cmd} ${{SRCS//{escaped_root_dir}\\//}} && cd "$TMP_DIR"'
    else:
        cmd += ' ${SRCS}'

    cmd = f'(export OUT_DIR=$TMP_DIR/{language_out_dir} && {cmd})'

    pkg_dir = package_name().removeprefix(root_dir).removeprefix("/")

    cmd += f' && (mv -f {language_out_dir}/{pkg_dir}/* {out_dir}; true) && (mv -f {language_out_dir}/* {out_dir}; true)'

    cmd = f'mkdir out_dir && mkdir {language_out_dir} && {cmd}'

    # protoc_flags are applied transitively to dependent rules via labels.
    labels += ['protoc:' + flag for flag in protoc_flags] + ["codegen"]
    return build_rule(
        name = name,
        tag = f'protoc_{language}',
        srcs = srcs,
        output_dirs = [f'{out_dir}/**'],
        cmd = cmd,
        deps = deps,
        tools = tools,
        requires = ['proto', language],
        pre_build = _collect_protoc_flags(pre_build),
        labels = labels,
        needs_transitive_deps = True,
        test_only = test_only,
        visibility = visibility,
    )

def filter_srcs(name, srcs, extension):
    """Filters re-exports its srcs filtering on the provided extension"""
    return build_rule(
        name = name,
        srcs = srcs,
        cmd = '\n'.join([
            'mkdir _out && for i in $SRCS; do ',
            f'   if [[ "$i" == *.{extension} ]]; then ',
            '        mkdir -p _out/$(dirname $i) ',
            '        mv $i _out/$i ',
            '     fi ',
            'done ']),
        output_dirs = ["_out/**"],
    )